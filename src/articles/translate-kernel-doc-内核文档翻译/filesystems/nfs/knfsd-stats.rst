============================
Kernel NFS Server Statistics
============================

本文是基于Documentation/filesystems/nfs/knfsd-stats.rst以下提交记录:

.. code-block:: shell

	commit cb63032b1233e03ac20fc2b60820a50d605b9bc0
	Author: Daniel W. S. Almeida <dwlsalmeida@gmail.com>
	Date:   Wed Jan 29 01:49:17 2020 -0300

	Documentation: nfs: knfsd-stats: convert to ReST

:Authors: Greg Banks <gnb@sgi.com> - 26 Mar 2009

本文档描述了内核 NFS 服务器提供给用户空间的统计信息的格式和语义。 这些统计数据以多个文本形式的伪文件提供，下面分别对每个文件进行描述。

在大多数情况下，您不需要知道这些格式，因为 nfs-utils 发行版中的 nfsstat(8) 程序提供了一个有用的命令行界面来提取和打印它们。

此处描述的所有文件都被格式化为一系列文本行，由换行符 '\n' 字符分隔。 以散列“#”字符开头的行是供人类使用的注释，解析例程应忽略。 所有其他行包含由空格分隔的字段序列。

/proc/fs/nfsd/pool_stats
========================

如果挂载了 /proc/fs/nfsd 文件系统（它几乎总是应该挂载），则该文件在 2.6.30 以后的内核中可用。

第一行是描述所有其他行中存在的字段的注释。 其他行将以下数据显示为一系列无符号十进制数字字段。 每个 NFS 线程池显示一行。

所有计数器都是 64 位宽并自然换行。 没有办法将这些计数器归零，而是应用程序应该进行自己的速率转换。

pool
        此行适用的 NFS 线程池的 ID 号。这个数字不会改变。

        线程池 ID 是一组从零开始的连续小整数。最大值取决于线程池模式，但目前不能大于系统中的 CPU 数量。请注意，在默认情况下，将有一个线程池，其中包含系统中的所有 nfsd 线程和所有 CPU，因此该文件将只有一行，池 ID 为“0”。

packets-arrived
        计算已到达的 NFS 数据包数量。更准确地说，这是网络堆栈通知 sunrpc 服务器层新数据可能在传输（例如 NFS 或 UDP 套接字或 NFS/RDMA 端点）上可用的次数。

        根据 NFS 工作负载模式和可以在线路上组合数据包的各种网络堆栈效应（例如大型接收卸载），这可能比收到的 NFS 调用数量更多或更少（该统计数据可在其他地方获得）。然而，这是一种更准确且与工作负载无关的测量方法，用于衡量由于 NFS 网络流量而在 sunrpc 服务器层上放置了多少 CPU 负载。

sockets-enqueued
        计算 NFS 传输排队等待 nfsd 线程为其提供服务的次数，即认为没有 nfsd 线程可用。

        该统计数据跟踪的情况表明，有面向 NFS 网络的工作要完成，但无法立即完成，从而在服务 NFS 调用时引入了小延迟。这个计数器的理想变化率是零；显着非零值可能表示性能限制。

        这可能是因为 NFS 工作负载的线程池中的 nfsd 线程太少（工作负载受线程限制），在这种情况下，配置更多 nfsd 线程可能会提高 NFS 工作负载的性能。

threads-woken
        计算空闲 nfsd 线程被唤醒以尝试从 NFS 传输接收一些数据的次数。

        此统计信息跟踪传入的面向网络的 NFS 工作被快速处理的情况，这是一件好事。该计数器的理想变化率将接近但小于数据包到达计数器的变化率。

threads-timedout
        计算 nfsd 线程触发空闲超时的次数，即一段时间内没有被唤醒以处理任何传入的网络数据包。

        此统计信息计算了配置的 nfsd 线程数超过 NFS 工作负载可以使用的数量的情况。这是一个线索，可以在不影响性能的情况下减少 nfsd 线程的数量。不幸的是，这只是一个线索，而不是一个强有力的迹象，原因如下：

         - 目前，计数器递增的速度非常慢； 空闲超时为 60 分钟。 除非 NFS 工作负载一次保持几个小时不变，否则此计数器不太可能提供仍然有用的信息。
         - 提供一些 slack 通常是一个明智的策略，即配置比当前需要的更多的 nfsd，以允许未来的负载峰值。


请注意，NFS 传输上的传入数据包将以三种方式之一进行处理。 一个 nfsd 线程可以被唤醒（threads-woken 计数这种情况），或者传输可以排队等待稍后注意（sockets-enqueued 计数这种情况），或者可以暂时推迟数据包，因为传输当前正被 nfsd thread 使用。 最后一种情况不是很有趣，也没有明确计算，但可以从其他计数器推断如下 ::

	packets-deferred = packets-arrived - ( sockets-enqueued + threads-woken )


More
====

其他统计文件的描述应该放在这里。
