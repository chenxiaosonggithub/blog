# 硬件分段

首先需要说明的是Linux系统是未利用段机制的。

但X86的段机制还是值得学习的。

段选择符segment selector字段:
```sh
 15          3  2 1 0
+-------------+--+---+
|    index    |TI|RPL|
+-------------+--+---+
TI = Table indicator 表指示器
RPL = requestor privilege level 请求者特权级
```

通过**段选择符**(segment selector)找到描述符表中的**段描述符**(segment descriptor):
```sh
        descriptor
          table                         segment 
      +------------+                 +-------------+
      |            |     +-.-.-.-.-.>|             |<-.-.-.-+
      +------------+     |           |             |        |
+---->|  segment   |     .           |             |        .
|     | descriptor |-.-.-+           |             |        |
|     +------------+                 |             |        .
|     |            |                 |             |        |
|     +------------+                 +-------------+        .
|                                                           |
|                                                           .
|       segmentation           (     nonprogrammable    )   |
|         register            (         register         )  .
|    +----------------+       (   +------------------+   )  |
+----|segment selector|       (   |segment descriptor|-.-)-.+
     +----------------+       (   +------------------+   )
                               (                        )
```

**段描述符**包含

```
段线性首地址
段长度
是否在内存中
代码段还是数据段
```

Linux的权限管理等都交由**分页机制**来完成

# Linux分页

线性地址(linear address）:
```sh
   +-------------+----------------+-------------+--------------+-------------+
   | global dir  |  upper dir     |  middle dir |     table    |     offset  |
   +-------------+----------------+-------------+--------------+-------------+
        |               |               |               |               |        
        |               |               |               |               |             
        |               |               |               |               |      page   
        |               |               |               |               |     +------+
        |               |               |               |               v     |      |
        |               |               |               |       page   (+)--->|======|
        |               |               |               |      table    ^     |      |
        |               |               |               |     +-----+   |     |      |
        |               |               |      page     v     |     |   |     +------+
        |               |               |     middle   (+)--->|=====|---+  
        |               |               |    director   ^     +-----+      
        |               |               |     +-----+   |                  
        |               |      page     v     |     |   |                  
        |               |     upper    (+)--->|=====|---+                  
        |               |    director   ^     +-----+                      
        |               |     +-----+   |                                  
        |     page      v     |     |   |                                  
        |    global    (+)--->|=====|---+                                  
        |   directory   ^     +-----+                                      
        |     +-----+   |                                        
        v     |     |   |                                     
       (+)--->|=====|---+                                                
        ^     +-----+                                           
        |                                              
+---+   |
|cr3|---+
+---+
```

不同体系结构对位数的划分不一样

页目录和页表包含以下内容

```
是否在内存中
读写权限
特权级
高速缓存处理方式
页框大小（页表）
```

# 回收页框

```
当系统负载较低时，内存中大部分由磁盘高速占用
系统负载增加时，内存大部分由进程页占用，高速缓存缩小
页框回收算法从用户态进程和内核高速缓存中回收页框
在万不得已的情况下，甚至会结束一些进程

虚拟内存允许进程使用比实际物理内存大的空间
Linux交换子系统在磁盘上建立swap area，专门用于存放没有磁盘映射的页（如动态分配的内存）
而有磁盘映射的页（如程序段）则直接丢弃
当需要访问该内存中不存在的页时，会触发缺页异常，相应的异常处理程序从磁盘换入RAM中缺失的页
```
