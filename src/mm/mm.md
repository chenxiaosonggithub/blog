本文章是从以前在海康威视做LoRaWAN研发时给同事分享的ppt内容整理而来，只是对linux内存管理的知识做一个概述，内容也有待补充和修改。

后续会再针对里面的某些知识点专门写一些文章。

# 简介

> 本文章的内容绝大多取材于以下2本书：
>
> Linux内核设计与实现-原书第3版 -- （美）Robert Love 著   陈莉君   康华   译
>
> 深入Linux内核-第3版 -- DANIEL P.BOVET & MARCO CESATI 著   陈莉君 张琼声  张宏伟 译

操作系统 ----- 横跨软件和硬件的桥梁

内存寻址 ----- 操作系统设计的硬件基础之一

```sh
logical                 linear              physical
address  +------------+ address  +--------+ address
-------->|segmentation|--------->| paging |--------->
         |   unit     |          |  unit  |
         +------------+          +--------+
```

# 硬件分段

首先需要说明的是Linux系统是未利用段机制的。

但X86的段机制还是值得学习的。

段选择符segment selector字段：
```sh
 15          3  2 1 0
+-------------+--+---+
|    index    |TI|RPL|
+-------------+--+---+
TI = Table indicator 表指示器
RPL = requestor privilege level 请求者特权级
```

通过**段选择符**(segment selector)找到描述符表中的**段描述符**(segment descriptor)：
```sh
        descriptor
          table                         segment 
      +------------+                 +-------------+
      |            |     +-.-.-.-.-.>|             |<-.-.-.-+
      +------------+     |           |             |        |
+---->|  segment   |     .           |             |        .
|     | descriptor |-.-.-+           |             |        |
|     +------------+                 |             |        .
|     |            |                 |             |        |
|     +------------+                 +-------------+        .
|                                                           |
|                                                           .
|       segmentation           (     nonprogrammable    )   |
|         register            (         register         )  .
|    +----------------+       (   +------------------+   )  |
+----|segment selector|       (   |segment descriptor|-.-)-.+
     +----------------+       (   +------------------+   )
                               (                        )
```

**段描述符**包含

```
段线性首地址
段长度
是否在内存中
代码段还是数据段
```

Linux更喜欢**分页**，但x86处理器无法绕过分段

RISC体系结构（如ARM）分段支持有限

Linux让x86所有的段都从0地址开始

Linux逻辑地址 == 线性地址

Linux的权限管理等都交由**分页机制**来完成

# Linux分页

线性地址(linear address）：
```sh
   +-------------+----------------+-------------+--------------+-------------+
   | global dir  |  upper dir     |  middle dir |     table    |     offset  |
   +-------------+----------------+-------------+--------------+-------------+
        |               |               |               |               |        
        |               |               |               |               |             
        |               |               |               |               |      page   
        |               |               |               |               |     +------+
        |               |               |               |               v     |      |
        |               |               |               |       page   (+)--->|======|
        |               |               |               |      table    ^     |      |
        |               |               |               |     +-----+   |     |      |
        |               |               |      page     v     |     |   |     +------+
        |               |               |     middle   (+)--->|=====|---+  
        |               |               |    director   ^     +-----+      
        |               |               |     +-----+   |                  
        |               |      page     v     |     |   |                  
        |               |     upper    (+)--->|=====|---+                  
        |               |    director   ^     +-----+                      
        |               |     +-----+   |                                  
        |     page      v     |     |   |                                  
        |    global    (+)--->|=====|---+                                  
        |   directory   ^     +-----+                                      
        |     +-----+   |                                        
        v     |     |   |                                     
       (+)--->|=====|---+                                                
        ^     +-----+                                           
        |                                              
+---+   |
|cr3|---+
+---+
```

不同体系结构对位数的划分不一样

页目录和页表包含以下内容

```
是否在内存中
读写权限
特权级
高速缓存处理方式
页框大小（页表）
```

通过物理地址扩展机制，分页使32位线性地址可以访问64G物理内存（处理器管脚36个）

![](http://chenxiaosong.com/pictures/mm-cache.png)

内存中的页表，访问速度慢

页面高速缓存，90%命中高速缓存，10%需要访问内存

# 进程地址空间

![](http://chenxiaosong.com/pictures/mm-virt-addr-space.png)

每个运行的进程虚拟地址空间4G

每个进程私有空间前3G，称为**用户空间**

后1G空间所有进程共享，称为**内核空间**

![](http://chenxiaosong.com/pictures/mm-layout.png)

**TEXT段**：程序代码段

**DATA段**：静态初始化的数据，所以有初值的全局变量（不为0）和static变量在data区

**BSS段**：Block Started by Symbol，通常是指用来存放程序中**未初始化或初始化为0**的全局变量的一块内存区域，在程序载入时由内核清0

用户态的进程运行时，可能只有少量页装入物理内存

当访问的虚拟内存页面未装入物理内存时，处理器会产生一个缺页异常

缺页异常发生时，操作系统将从磁盘或交换文件（SWAP）中将要访问的页装入物理内存

Linux总是**尽量延后**分配用户空间的内存

# 伙伴算法

```
伙伴算法的目的是对内存中的空闲碎片回收，让内存的利用率达到最大
把所有空闲页面分为12个块链表，每个链表中的块分别含有2，4，8 。。。个页面
大小相同、物理地址连续的2个页块被称为伙伴
工作原理：在满足大小要求的链表中查找是否有空闲块，有则直接分配，否则在更大的块中查找。逆过程为块的合并

如申请大小为2^3 = 8的页块，却在块大小为2^5 = 32的链表上找到空闲块
先将32个页面对半等分，前一半分配使用，另一半插入块大小为16的链表
继续将前一半大小为16的页块等分，一半分配，另一半插入大小为8的链表
回收的过程与上述分配过程相反
```

# 回收页框

```
当系统负载较低时，内存中大部分由磁盘高速占用
系统负载增加时，内存大部分由进程页占用，高速缓存缩小
页框回收算法从用户态进程和内核高速缓存中回收页框
在万不得已的情况下，甚至会结束一些进程

虚拟内存允许进程使用比实际物理内存大的空间
Linux交换子系统在磁盘上建立swap area，专门用于存放没有磁盘映射的页（如动态分配的内存）
而有磁盘映射的页（如程序段）则直接丢弃
当需要访问该内存中不存在的页时，会触发缺页异常，相应的异常处理程序从磁盘换入RAM中缺失的页
```

# `enum pageflags`

在内核代码中，我们经常看到类似`SetPageError`、`PagePrivate`的函数，但总是找不到定义，这是因为这些函数是通过宏定义生成的。

宏定义是对`enum pageflags`中的每个值进行宏展开，这里写出设置和检测的宏定义：
```c
// 检测
#define TESTPAGEFLAG(uname, lname, policy)                       
static __always_inline int Page##uname(struct page *page)        
        { return test_bit(PG_##lname, &policy(page, 0)->flags); }

// 设置                                          
#define SETPAGEFLAG(uname, lname, policy)                        
static __always_inline void SetPage##uname(struct page *page)    
        { set_bit(PG_##lname, &policy(page, 1)->flags); }        
```