# 1. 问题描述

环境信息：
```sh
# uname -a
Linux server-v10-sp2-x86 4.19.90-25.30.v2101.ky10.x86_64 #1 SMP Thu Aug 17 18:12:26 CST 2023 x86_64 x86_64 x86_64 GNU/Linux

# mount | grep nfs
172.20.190.58:/data/iso on /data/iso type nfs4 (rw,relatime,vers=4.2,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=172.20.190.55,local_lock=none,addr=172.20.190.58,_netdev)
nfsd on /proc/fs/nfsd type nfsd (rw,relatime)
```

dmesg日志：
```sh
BUG: unable to handle kernel NULL pointer dereference at 0000000000000000      
CPU: 104 PID: 1861326 Comm: filebeat Kdump: loaded Tainted: G        W         4.19.90-24.4.v2101.ky10.x86_64 #1
Hardware name: Lenovo ThinkServer SR658H V2/HengShan    , BIOS HSE166A-1.16 01/05/2023
RIP: 0010:nfs_readpage_async+0x67/0x2d0 [nfs]
Call Trace:
 nfs_readpage+0x121/0x1e0 [nfs]
 generic_file_read_iter+0x60f/0xba0
 nfs_file_read+0x66/0xa0 [nfs]
 new_sync_read+0xfa/0x160
 vfs_read+0x89/0x130
 ksys_read+0x5a/0xd0
 do_syscall_64+0x5b/0x1d0
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
```

用`faddr2line`脚本解析：
```sh
server-v10-sp2-x86:~# ./faddr2line fs/nfs/nfs.ko.debug nfs_readpage_async+0x67/0x2d0
nfs_readpage_async+0x67/0x2d0:
page_file_mapping 于 /usr/src/debug/kernel-4.19.90/linux-4.19.90-24.4.v2101.ky10.x86_64/./include/linux/mm.h:1242
(已内连入)nfs_page_length 于 /usr/src/debug/kernel-4.19.90/linux-4.19.90-24.4.v2101.ky10.x86_64/fs/nfs/internal.h:681
(已内连入)nfs_readpage_async 于 /usr/src/debug/kernel-4.19.90/linux-4.19.90-24.4.v2101.ky10.x86_64/fs/nfs/read.c:118
```

空指针解引用发生在`nfs_readpage_async -> nfs_page_length -> page_file_mapping`的语句`return page->mapping`，因为`page_file_mapping`是内联函数，所以空指针解引用是发生在`nfs_page_length`函数中的`loff_t i_size = i_size_read(page_file_mapping(page)->host)`，`host`成员在`struct address_space`中的偏移量为0。

# 2. vmcore解析

加载nfs相关ko文件：
```sh
crash> mod -s nfs fs/nfs/nfs.ko.debug 
crash> mod -s nfsv3 fs/nfs/nfsv3.ko.debug
crash> mod -s nfsv4 fs/nfs/nfsv4.ko.debug
crash> mod -s nfs_acl fs/nfs_common/nfs_acl.ko.debug
crash> mod -s grace fs/nfs_common/grace.ko.debug
```

查看栈的信息：
```sh
crash> bt -FF
#7 [ffffbcb34f133ba0] page_fault at ffffffff8c80116e
    [exception RIP: nfs_readpage_async+103]
    RIP: ffffffffc0a43047  RSP: ffffbcb34f133c50  RFLAGS: 00010246
    RAX: 0000000000000000  RBX: ffffe3e4768a6080  RCX: 0000000000000000
    RDX: 01d7ffffc0000001  RSI: ffff97a5b452a940  RDI: ffff979b656b3280
    RBP: ffff97a5b452a940   R8: 0000000000000001   R9: 0000000000000000
    R10: ffff97a6f6213680  R11: 0000000000000000  R12: ffff97a5b452a940
    R13: ffff979b656b3280  R14: ffff97a5b452aab0  R15: ffffbcb34f133e60
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
    ffffbcb34f133ba8: ffffbcb34f133e60 [ffff97a5b452aab0:nfs_inode_cache]
    ffffbcb34f133bb8: [ffff979b656b3280:kmalloc-128] [ffff97a5b452a940:nfs_inode_cache]
    ffffbcb34f133bc8: [ffff97a5b452a940:nfs_inode_cache] ffffe3e4768a6080
    ffffbcb34f133bd8: 0000000000000000 [ffff97a6f6213680:secpath_cache]
    ffffbcb34f133be8: 0000000000000000 0000000000000001
    ffffbcb34f133bf8: 0000000000000000 0000000000000000
    ffffbcb34f133c08: 01d7ffffc0000001 [ffff97a5b452a940:nfs_inode_cache]
    ffffbcb34f133c18: [ffff979b656b3280:kmalloc-128] ffffffffffffffff
    ffffbcb34f133c28: nfs_readpage_async+103 0000000000000010
    ffffbcb34f133c38: 0000000000010246 ffffbcb34f133c50
    ffffbcb34f133c48: 0000000000000018 ffffbcb34f133c80
    ffffbcb34f133c58: ffffbcb34f133dd8 [ffff97a5b452aab0:nfs_inode_cache]
    ffffbcb34f133c68: ffffbcb34f133e60 nfs_wb_page+190
    ffffbcb34f133c78: 0000000000000246 0000000000000000
    ffffbcb34f133c88: 0000000000000000 00000000019d3000
    ffffbcb34f133c98: 00000000019d3fff 0000000000000001
    ffffbcb34f133ca8: 0000000000000000 0000000000000000
    ffffbcb34f133cb8: 0000000000000000 0000000000000000
    ffffbcb34f133cc8: 0000000000000000 0000000000000000
    ffffbcb34f133cd8: 0000000000000000 0000000000000000
    ffffbcb34f133ce8: 0000000000000000 faff81de0e046600
    ffffbcb34f133cf8: ffffe3e4768a6080 [ffff97a5b452a940:nfs_inode_cache]
    ffffbcb34f133d08: [ffff979b656b3280:kmalloc-128] 0000000000000000
    ffffbcb34f133d18: nfs_readpage+289
#8 [ffffbcb34f133d18] nfs_readpage at ffffffffc0a433d1 [nfs]
    ffffbcb34f133d20: ffffe3e4768a6080 0000000000004000
    ffffbcb34f133d30: [ffff97a5b452a940:nfs_inode_cache] ffffbcb34f133dd8
    ffffbcb34f133d40: generic_file_read_iter+1551
```

x86_64架构下整数参数使用的寄存器依次为：RDI，RSI，RDX，RCX，R8，R9，从栈帧数据中可以看出函数`int nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode, struct page *page)`第三个参数为`RDX: 01d7ffffc0000001`：
```sh
crash> struct page 01d7ffffc0000001
struct: invalid kernel virtual address: 01d7ffffc0000001
```
显然不是一个有效的地址，说明`page`已经被释放。

再看一下`nfs_readpage_async`函数的第二个参数`RSI: ffff97a5b452a940`：
```sh
crash> kmem ffff97a5b452a940
  NAME
  nfs_inode_cache
  ...
  FREE / [ALLOCATED]
  [ffff97a5b452a760] # 栈中[ffff97a5b452a940:nfs_inode_cache]的含义

crash> struct nfs_inode ffff97a5b452a760 -ox
struct nfs_inode {
  ...
  [ffff97a5b452a940] struct inode vfs_inode; # 可以看出`struct inode`是嵌套在`struct nfs_inode`中的
}
SIZE: 0x458

crash> struct inode ffff97a5b452a940 -x
struct inode {
  ...
  i_mapping = 0xffff97a5b452aab0,
  ...
}
```

地址`0xffff97a5b452aab0`存在于栈中，具体为什么，有待分析。

# 3. 代码分析

先看一下`mapping`成员在`struct page`中的偏移量：
```sh
gdb vmlinux # crash中执行struct page -o看不到mapping的偏移量，所以我就用gdb了

(gdb) p &((struct page *)0)->mapping
$2 = (struct address_space **) 0x18 <irq_stack_union+24>
```

这里有个地方我个人很迷惑，发生空指针解引用时，`nfs_readpage_async`的第三个参数`page`不是一个有效的地址，这时应该报错：在地址`0x01d7ffffc0000001+0x18`发生空指针解引用（0x18为`mapping`成员在`struct page`中的偏移量）。但报错的信息是在地址0发生空指针解引用，就说明成功的取出了`page->mapping`的值。
```c
read
  ksys_read
    vfs_read
      new_sync_read
        nfs_file_read
          generic_file_read_iter
            nfs_readpage
              inode = page_file_mapping(page)->host // 这里没问题
              // 从vmcore的栈中可以看到page不是一个有效地址
              nfs_readpage_async
                nfs_page_length
                  page_file_mapping(page)->host // 发生空指针解引用
                    page->mapping == 0 // 日志中显示在0地址发生空指针解引用，可以得出page->mapping为0
```

# 4. 构造

以下修改使得执行命令`cat /mnt/file`可以调用到函数`nfs_readpage`：
```sh
diff --git a/mm/readahead.c b/mm/readahead.c
index 4e630143a0ba..5cb303815e5f 100644
--- a/mm/readahead.c
+++ b/mm/readahead.c
@@ -119,7 +119,7 @@ static int read_pages(struct address_space *mapping, struct file *filp,
 
        blk_start_plug(&plug);
 
-       if (mapping->a_ops->readpages) {
+       if (0) { // mapping->a_ops->readpages) {
                ret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);
                /* Clean up the remaining pages */
                put_pages_list(pages);
```