[点击这里跳转到陈孝松个人主页:chenxiaosong.com](http://chenxiaosong.com/)。

# CVE描述

2022年2月左右，在分析[CVE-2022-24448](https://nvd.nist.gov/vuln/detail/CVE-2022-24448)当时的修复补丁`ac795161c936 NFSv4: Handle case where the lookup of a directory fails`时，发现始终都无法复现出补丁描述的问题。

发邮件[Question about CVE-2022-24448](https://lore.kernel.org/all/1bb42908-8f58-bf56-c2da-42739ee48d16@huawei.com/T/)问了nfs maintainer和CVE的报告者，maintainer没回答，CVE报告者Lyu Tao给出了复现程序：
```sh
  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/
  2. fd = open("/mnt/file", O_ACCMODE|O_DIRECT|O_CREAT)
  3. close(fd)
  4. fd = open("/mnt/file", O_ACCMODE|O_DIRECT)
  5. lseek(fd) // 空指针解引用
```

由于nfs maintainer始终不回答，就决定自己解决。

将问题补丁如了回退，修复补丁：[Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)后，原本的问题也暴露出来了:
```sh
  1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/
  2. fd = open("/mnt/file", O_ACCMODE|O_DIRECT|O_CREAT)
  3. close(fd)
  4. fd = open("/mnt/file", O_ACCMODE|O_DIRECT) // 打开文件失败
```

修复补丁：[NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)。

# 空指针解引用问题代码分析

第二次调用open()时:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          open_last_lookups
            lookup_open
              return dentry // if (dentry->d_inode) {
          do_open
            vfs_open
              do_dentry_open
                nfs4_file_open // f->f_op->open
                  if ((openflags & O_ACCMODE) == 3)
                  nfs_open // 没有发送RPC请求
                    alloc_nfs_open_context
                      ctx->state = NULL; // 再执行lseek时发生空指针解引用
```

再调用lseek():
```c
lseek
  ksys_lseek
    vfs_llseek
      nfs4_file_llseek // file->f_op->llseek
        nfs42_proc_llseek
          _nfs42_proc_llseek(lock)
            nfs4_set_rw_stateid(ctx=lock->open_context)
              nfs4_select_rw_stateid(state=ctx->state)
                nfs4_valid_open_stateid(state)
                  state->flags // 空指针解引用
```

# 打开文件失败问题代码分析

将问题补丁如了回退：[Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)后。

第一次以`O_ACCMODE`标志打开文件:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          open_last_lookups
            lookup_open
              atomic_open
                nfs_atomic_open
                  create_nfs_open_context
                    flags_to_mode() = FMODE_READ|FMODE_WRITE
                    alloc_nfs_open_context
                      ctx->mode = f_mode // FMODE_READ|FMODE_WRITE
                  nfs4_atomic_open // NFS_PROTO(dir)->open_context
                    nfs4_do_open
                      _nfs4_do_open
                        fmode = _nfs4_ctx_to_openmode(ctx) = 3
                          ret = ctx->mode & (FMODE_READ|FMODE_WRITE) // ctx->mode = 3
                        nfs4_opendata_alloc
                          nfs4_map_atomic_open_share
                            return NFS4_SHARE_ACCESS_BOTH // 这将决定文件打开成功
```

第二次以`O_ACCMODE`标志打开文件:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          open_last_lookups
            lookup_open
              return dentry // if (dentry->d_inode) {
          do_open
            vfs_open
              do_dentry_open
                nfs4_file_open // f->f_op->open
                  if ((openflags & O_ACCMODE) == 3)
                  openflags-- == O_RDWR
                  nfs4_atomic_open // NFS_PROTO(dir)->open_context
                    nfs4_do_open
                      _nfs4_do_open
                        fmode = _nfs4_ctx_to_openmode(ctx) = 0
                          ret = ctx->mode & (FMODE_READ|FMODE_WRITE) // ctx->mode = 0
                        nfs4_opendata_alloc
                          p->o_arg.share_access = nfs4_map_atomic_open_share = 0 // 这将决定文件打开失败
                            return 0
```

第二次请求打开文件时，server处理流程如下：
```c
nfsd4_decode_open
  nfsd4_decode_share_access
    switch (w & NFS4_SHARE_ACCESS_MASK) // 0
    return nfserr_bad_xdr // 回复错误，client打开文件失败
```