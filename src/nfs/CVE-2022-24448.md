[点击这里跳转到陈孝松个人主页:chenxiaosong.com](http://chenxiaosong.com/)。

# CVE描述

2022年2月左右，在分析[CVE-2022-24448](https://nvd.nist.gov/vuln/detail/CVE-2022-24448)当时的修复补丁`ac795161c936 NFSv4: Handle case where the lookup of a directory fails`时，发现始终都无法复现出补丁描述的问题。

发邮件[Question about CVE-2022-24448](https://lore.kernel.org/all/1bb42908-8f58-bf56-c2da-42739ee48d16@huawei.com/T/)问了nfs maintainer和CVE的报告者，maintainer没回答，CVE报告者Lyu Tao给出了复现程序：
```sh
1. shell命令: mount -t nfs -o vers=4.2 $server_ip:/ /mnt/
2. c程序: fd = open("/mnt/file", O_ACCMODE|O_DIRECT|O_CREAT)
3. c程序: close(fd)
4. c程序: fd = open("/mnt/file", O_ACCMODE|O_DIRECT)
5. c程序: lseek(fd) // 空指针解引用
```

由于nfs maintainer始终不回答，就决定自己解决。

将问题补丁如了回退，修复补丁：[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)后，原本的问题也暴露出来了:
```sh
1. shell命令: mount -t nfs -o vers=4.2 $server_ip:/ /mnt/
2. c程序: fd = open("/mnt/file", O_ACCMODE|O_DIRECT|O_CREAT)
3. c程序: close(fd)
4. c程序: fd = open("/mnt/file", O_ACCMODE|O_DIRECT) // 打开文件失败
```

修复补丁：[b243874f6f95 NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)。

[openEuler kernel的issue](https://gitee.com/openeuler/kernel/issues/I5BZTX)。

# 空指针解引用问题代码分析

修复补丁：[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)

第二次调用open()时:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          open_last_lookups
            lookup_open
              return dentry // if (dentry->d_inode) {
          do_open
            vfs_open
              do_dentry_open
                nfs4_file_open // f->f_op->open
                  if ((openflags & O_ACCMODE) == 3)
                  nfs_open // 没有发送RPC请求
                    alloc_nfs_open_context
                      ctx->state = NULL; // 再执行lseek时发生空指针解引用
```

再调用lseek():
```c
lseek
  ksys_lseek
    vfs_llseek
      nfs4_file_llseek // file->f_op->llseek
        nfs42_proc_llseek
          _nfs42_proc_llseek(lock)
            nfs4_set_rw_stateid(ctx=lock->open_context)
              nfs4_select_rw_stateid(state=ctx->state)
                nfs4_valid_open_stateid(state)
                  state->flags // 空指针解引用
```

# 打开文件失败问题代码分析

修复补丁：[b243874f6f95 NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)

将问题补丁如了回退：[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)后。第一次以`O_ACCMODE`标志打开文件:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          open_last_lookups
            lookup_open
              atomic_open
                nfs_atomic_open
                  create_nfs_open_context
                    flags_to_mode() = FMODE_READ|FMODE_WRITE
                    alloc_nfs_open_context
                      ctx->mode = f_mode // FMODE_READ|FMODE_WRITE
                  nfs4_atomic_open // NFS_PROTO(dir)->open_context
                    nfs4_do_open
                      _nfs4_do_open
                        fmode = _nfs4_ctx_to_openmode(ctx) = 3
                          ret = ctx->mode & (FMODE_READ|FMODE_WRITE) // ctx->mode = 3
                        nfs4_opendata_alloc
                          nfs4_map_atomic_open_share
                            return NFS4_SHARE_ACCESS_BOTH // 这将决定文件打开成功
```

第二次以`O_ACCMODE`标志打开文件:
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          alloc_empty_file
            init_file
              f->f_mode = OPEN_FMODE(flags) = 0 // 其他bit可能不为0
                (flag + 1) & O_ACCMODE) = (3 + 1) & 3 = 0
          open_last_lookups
            lookup_open
              return dentry // if (dentry->d_inode) {
          do_open
            vfs_open
              do_dentry_open
                nfs4_file_open // f->f_op->open
                  if ((openflags & O_ACCMODE) == 3)
                  openflags-- == O_RDWR
                  alloc_nfs_open_context(..., filp->f_mode, ...)
                    ctx->mode = f_mode = 0
                  nfs4_atomic_open // NFS_PROTO(dir)->open_context
                    nfs4_do_open
                      _nfs4_do_open
                        fmode = _nfs4_ctx_to_openmode(ctx) = 0
                          ret = ctx->mode & (FMODE_READ|FMODE_WRITE) // ctx->mode = 0，其他bit可能不为0
                        nfs4_opendata_alloc
                          p->o_arg.share_access = nfs4_map_atomic_open_share = 0 // 这将决定文件打开失败
                            return 0
```

第二次请求打开文件时，server处理流程如下：
```c
nfsd4_decode_open
  nfsd4_decode_share_access
    switch (w & NFS4_SHARE_ACCESS_MASK) // 0
    return nfserr_bad_xdr // 回复错误，client打开文件失败
```

如果没有合入[90cf500e338a NFSv4: Fix return values for nfs4_file_open()](https://lore.kernel.org/all/20190813142806.123268-2-trond.myklebust@hammerspace.com/)（比如某些低版本的LTS或某些公司自己维护的版本），第二次以`O_ACCMODE`标志打开文件会成功，具体流程如下：
```c
open
  do_sys_open
    do_sys_openat2
      do_filp_open
        path_openat
          alloc_empty_file
            init_file
              f->f_mode = OPEN_FMODE(flags) = 0 // 其他bit可能不为0
                (flag + 1) & O_ACCMODE) = (3 + 1) & 3 = 0
          open_last_lookups
            lookup_open
              return dentry // if (dentry->d_inode) {
          do_open
            vfs_open
              do_dentry_open
                nfs4_file_open // f->f_op->open
                  if ((openflags & O_ACCMODE) == 3)
                  openflags-- == O_RDWR
                  alloc_nfs_open_context(..., filp->f_mode, ...)
                    ctx->mode = f_mode = 0
                  nfs4_atomic_open // open失败
                  goto out_drop
                  err = -EOPENSTALE
                  return -EOPENSTALE
          if (error == -EOPENSTALE) // 条件满足
          error = -ESTALE
        filp = path_openat // 这次open成功
```

# 从`nfs_open_context->mode`判断`FMODE_EXEC`

[NFS: check FMODE_EXEC from open context mode](https://lore.kernel.org/all/20220923054015.2890271-1-chenxiaosong2@huawei.com/)

通过`flags_to_mode()`函数的转换，确保当open flag中含有`__FMODE_EXEC`时，`nfs_open_context->mode`中也能含有`FMODE_EXEC`。当我们需要判断`fmode_t`中是否含有`FMODE_EXEC`时，就不需要open flag，一些函数的参数中也不需要传入open flag。

# 测试用例

`null-ptr-deref-test.c`文件：
```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int fd;

    // 打开文件，O_ACCMODE 表示读写权限，O_DIRECT 表示直接 I/O，O_CREAT 表示如果文件不存在则创建
    fd = open("/mnt/file", O_ACCMODE | O_DIRECT | O_CREAT);

    if (fd == -1) {
        perror("无法打开/创建文件");
        return EXIT_FAILURE;
    }

    // 关闭文件
    close(fd);

    // 重新打开文件，O_ACCMODE 表示读写权限，O_DIRECT 表示直接 I/O
    fd = open("/mnt/file", O_ACCMODE | O_DIRECT);

    if (fd == -1) {
        perror("无法重新打开文件");
        return EXIT_FAILURE;
    }

    // 进行 lseek 操作（在这里只是示例，实际使用时可能需要根据具体需求进行调整）
    if (lseek(fd, 0, SEEK_SET) == -1) {
        perror("lseek 操作失败");
        close(fd);
        return EXIT_FAILURE;
    }

    // 关闭文件
    close(fd);

    return EXIT_SUCCESS;
}
```

`open-fail-test.c`文件：
```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int fd;

    // 打开文件，O_ACCMODE 表示读写权限，O_DIRECT 表示直接 I/O，O_CREAT 表示如果文件不存在则创建
    fd = open("/mnt/file", O_ACCMODE | O_DIRECT | O_CREAT);

    if (fd == -1) {
        perror("无法打开/创建文件");
        return EXIT_FAILURE;
    }

    // 关闭文件
    close(fd);

    // 重新打开文件，O_ACCMODE 表示读写权限，O_DIRECT 表示直接 I/O
    fd = open("/mnt/file", O_ACCMODE | O_DIRECT);

    if (fd == -1) {
        perror("无法重新打开文件");
        return EXIT_FAILURE;
    }

    // 关闭文件
    close(fd);

    return EXIT_SUCCESS;
}
```

启动nfs server后，测试步骤:
```sh
mount -t nfs -o vers=4.2 localhost:/ /mnt/ # 既当客户端，又当服务端
gcc null-ptr-deref-test.c -o null-ptr-deref-test
gcc open-fail-test.c -o open-fail-test
./open-fail-test; echo $? # 最新的主线代码预期打开文件成功，输出0
echo 3 > /proc/sys/vm/drop_caches
./null-ptr-deref-test # 最新的主线代码预期不发生空指针解引用，不发生panic
```

有以下几种情况：

1. 两个修复补丁**都合入**[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)和[b243874f6f95 NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)，`open-fail-test`程序和`null-ptr-deref-test`程序都执行成功。
2. 两个修复补丁**都没合入**[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)和[b243874f6f95 NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)，`open-fail-test`程序执行成功，`null-ptr-deref-test`程序执行失败。
3. **只合入**[ab0fc21bc710 Revert "NFSv4: Handle the special Linux file open access mode"](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-2-chenxiaosong2@huawei.com/)，没合入[b243874f6f95 NFSv4: fix open failure with O_ACCMODE flag](https://patchwork.kernel.org/project/linux-nfs/patch/20220329113208.2466000-3-chenxiaosong2@huawei.com/)，`open-fail-test`程序执行失败，`null-ptr-deref-test`程序执行成功。