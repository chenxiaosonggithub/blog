.. SPDX-License-Identifier: GPL-2.0

================================================
Multi-Queue Block IO Queueing Mechanism (blk-mq)（多队列块 IO 排队机制 (blk-mq)）
================================================

本文是基于Documentation/block/blk-mq.rst以下提交记录:

.. code-block:: shell

        commit 8ac867340bd8cc8c65d4cafbf634873b8ddcf3f7
        Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
        Date:   Tue Sep 29 10:04:26 2020 +0200

        docs: block: blk-mq.rst: get rid of :c:type

Multi-Queue Block IO Queuing Mechanism 是一种 API，可让快速存储设备通过排队并同时向块设备提交 IO 请求来实现每秒大量的输入/输出操作 (IOPS)，受益于现代存储提供的并行性 设备。

Introduction
============

Background
----------

从内核开发之初，磁硬盘一直是事实上的标准。 Block IO 子系统旨在为那些在进行随机访问时具有高惩罚的设备实现最佳性能，而瓶颈是机械运动部件，比存储堆栈上的任何层慢得多。这种优化技术的一个例子涉及根据硬盘磁头的当前位置对读/写请求进行排序。

然而，随着固态驱动器和非易失性存储器的发展，没有机械部件，也没有随机访问惩罚，能够执行高并行访问，堆栈的瓶颈已经从存储设备转移到了操作系统。为了利用这些设备设计中的并行性，引入了多队列机制。

前一种设计有一个单独的队列来存储带有单个锁的块 IO 请求。由于缓存中的脏数据和多个处理器的单一锁的瓶颈，这在 SMP 系统中不能很好地扩展。当不同的进程（或同一进程，移动到不同的 CPU）想要执行块 IO 时，这种设置也会遇到拥塞。取而代之的是，blk-mq API 会生成多个队列，这些队列具有 CPU 本地的各个入口点，从而无需锁定。下一节(`Operation`_)将更深入地解释其工作原理。

Operation
---------

当用户空间对块设备执行 IO（例如读取或写入文件）时，blk-mq 会采取行动：它将存储和管理对块设备的 IO 请求，充当用户空间（和文件系统，如果存在）和块设备驱动程序。

blk-mq 有两组队列：软件暂存队列和硬件调度队列。当请求到达块层时，它会尝试尽可能最短的路径：直接将其发送到硬件队列。但是，有两种情况它可能不会这样做：如果在该层附加了 IO 调度程序，或者如果我们想尝试合并请求。在这两种情况下，请求都会被发送到软件队列。

然后，在软件队列处理完请求后，它们将被放置在硬件队列中，第二阶段队列是硬件可以直接访问以处理这些请求。但是，如果硬件没有足够的资源来接受更多的请求，blk-mq 会将请求放置在一个临时队列中，以便将来在硬件有能力时发送。

Software staging queues(软件暂存队列)
~~~~~~~~~~~~~~~~~~~~~~~

块 IO 子系统将请求添加到软件暂存队列（由 struct blk_mq_ctx 表示）中，以防它们没有直接发送到驱动程序。一个请求是一个或多个 BIO。他们通过数据结构struct bio到达了block层。然后块层会从中构建一个新的结构，这个结构请求将用于与设备驱动程序进行通信。每个队列都有自己的锁，队列的数量由每个 CPU 或每个节点定义。

分段队列可用于合并相邻扇区的请求。例如，对扇区 3-6、6-7、7-9 的请求可以成为对 3-9 的一个请求。即使与顺序访问相比，对 SSD 和 NVM 的随机访问具有相同的响应时间，顺序访问的分组请求也会减少单个请求的数量。这种合并请求的技术称为插入。

除此之外，可以通过 IO 调度程序重新排序请求以确保系统资源的公平性（例如，确保没有应用程序遭受饥饿）和/或提高 IO 性能。

IO Schedulers
^^^^^^^^^^^^^

块层实现了多个调度程序，每个调度程序都遵循启发式方法来提高 IO 性能。 它们是“可插拔的”（如即插即用），因为它们可以在运行时使用 sysfs 进行选择。 您可以在 `此处 <https://www.kernel.org/doc/html/latest/block/index.html>`_ 阅读有关 Linux IO 调度程序的更多信息。 调度只发生在同一个队列中的请求之间，所以不能合并来自不同队列的请求，否则会出现缓存垃圾，并且需要为每个队列都有一个锁。 在调度之后，请求有资格被发送到硬件。 要选择的可能调度程序之一是 NONE 调度程序，这是最直接的一种。 它只会将请求放置在进程正在运行的任何软件队列上，而无需任何重新排序。 当设备开始处理硬件队列中的请求（即运行硬件队列）时，映射到该硬件队列的软件队列将根据它们的映射顺序排空。

Hardware dispatch queues(硬件调度队列)
~~~~~~~~~~~~~~~~~~~~~~~~

硬件队列（由struct blk_mq_hw_ctx表示）是设备驱动用来映射设备提交队列（或设备DMA环形缓冲区）的结构，是底层设备驱动取得所有权之前的块层提交代码的最后一步请求。为了运行这个队列，块层从相关的软件队列中删除请求并尝试分派到硬件。

如果无法将请求直接发送到硬件，它们将被添加到请求的链表 (hctx->dispatch) 中。然后，下一次块层运行队列时，它将首先发送位于调度列表中的请求，以确保对那些准备好首先发送的请求进行公平调度。硬件队列的数量取决于硬件及其设备驱动支持的硬件上下文的数量，但不会超过系统的核心数量。在这个阶段没有重新排序，每个软件队列都有一组硬件队列来发送请求。

.. note::

        块层和设备协议都不能保证请求的完成顺序。这必须由更高层处理，例如文件系统。



Tag-based completion(基于标签的补全)
~~~~~~~~~~~~~~~~~~~~

为了指示哪个请求已经完成，每个请求都由一个整数标识，范围从 0 到调度队列大小。该标签由块层生成，稍后由设备驱动程序重用，无需创建冗余标识符。当驱动器中的请求完成时，标签被发送回块层以通知它完成。这消除了进行线性搜索以找出已完成的 IO 的需要。

Further reading
---------------

- `Linux Block IO: Introducing Multi-queue SSD Access on Multi-core Systems <http://kernel.dk/blk-mq.pdf>`_

- `NOOP scheduler <https://en.wikipedia.org/wiki/Noop_scheduler>`_

- `Null block device driver <https://www.kernel.org/doc/html/latest/block/null_blk.html>`_

Source code documentation
=========================

.. kernel-doc:: include/linux/blk-mq.h

.. kernel-doc:: block/blk-mq.c
